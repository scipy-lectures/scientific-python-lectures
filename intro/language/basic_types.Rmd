---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.17.1
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Basic types

## Numerical types

::: {note}
:class: dropdown

Python supports the following numerical, scalar types:
:::


Floats:

```{python}
c = 2.1
type(c)
```

Complex:

```{python}
a = 1.5 + 0.5j
a.real
```

```{python}
a.imag
```

```{python}
type(1. + 0j)
```

Booleans:

```{python}
3 > 4
```

```{python}
test = (3 > 4)
test
```

```{python}
type(test)
```

::: {note}
:class: dropdown

A Python shell can therefore replace your pocket calculator, with the
basic arithmetic operations `+`, `-`, `*`, `/`, `%` (modulo)
natively implemented
:::

```{python}
7 * 3.
```

```{python}
2**10
```

```{python}
8 % 3
```

Type conversion (casting):

```{python}
float(1)
```

## Containers

::: {note}
:class: dropdown

Python provides many efficient types of containers, in which
collections of objects can be stored.
:::

### Lists

::: {note}
:class: dropdown

A list is an ordered collection of objects, that may have different
types. For example:
:::

```{python}
colors = ['red', 'blue', 'green', 'black', 'white']
type(colors)
```

Indexing: accessing individual objects contained in the list:

```{python}
colors[2]
```

Counting from the end with negative indices:

```{python}
colors[-1]
```

```{python}
colors[-2]
```

:::{warning}
**Indexing starts at 0** (as in C), not at 1 (as in Fortran or Matlab)!
:::

Slicing: obtaining sublists of regularly-spaced elements:

```{python}
colors
```

```{python}
colors[2:4]
```

:::{Warning}
Note that `colors[start:stop]` contains the elements with indices `i`
such as `start<= i < stop` (`i` ranging from `start` to
`stop-1`). Therefore, `colors[start:stop]` has `(stop - start)` elements.
:::

**Slicing syntax**: `colors[start:stop:stride]`

::: {note}
:class: dropdown

All slicing parameters are optional:

```{python}
colors
```

```{python}
colors[3:]
```

```{python}
colors[:3]
```

```{python}
colors[::2]
```
:::

Lists are *mutable* objects and can be modified:

```{python}
colors[0] = 'yellow'
colors
```

```{python}
colors[2:4] = ['gray', 'purple']
colors
```

::::{Note}
The elements of a list may have different types:

```{python}
colors = [3, -200, 'hello']
colors
```

```{python}
colors[1], colors[2]
```

::: {note}
:class: dropdown

For collections of numerical data that all have the same type, it
is often **more efficient** to use the `array` type provided by
the `numpy` module. A NumPy array is a chunk of memory
containing fixed-sized items. With NumPy arrays, operations on
elements can be faster because elements are regularly spaced in
memory and more operations are performed through specialized C
functions instead of Python loops.
:::
::::

::: {note}
:class: dropdown

Python offers a large panel of functions to modify lists, or query
them. Here are a few examples; for more details, see
<https://docs.python.org/3/tutorial/datastructures.html#more-on-lists>
:::

Add and remove elements:

```{python}
colors = ['red', 'blue', 'green', 'black', 'white']
colors.append('pink')
colors
```

```{python}
colors.pop() # removes and returns the last item
```

```{python}
colors
```

```{python}
colors.extend(['pink', 'purple']) # extend colors, in-place
colors
```

```{python}
colors = colors[:-2]
colors
```

Reverse:

```{python}
rcolors = colors[::-1]
rcolors
```

```{python}
rcolors2 = list(colors) # new object that is a copy of colors in a different memory area
rcolors2
```

```{python}
rcolors2.reverse() # in-place; reversing rcolors2 does not affect colors
rcolors2
```

Concatenate and repeat lists:

```{python}
rcolors + colors
```

```{python}
rcolors * 2
```

::: {note}
:class: dropdown

Sort:

```{python}
sorted(rcolors) # new object
```

```{python}
rcolors
```

```{python}
rcolors.sort()  # in-place
rcolors
```
:::

:::{admonition} Methods and Object-Oriented Programming
The notation `rcolors.method()` (e.g. `rcolors.append(3)` and `colors.pop()`) is our
first example of object-oriented programming (OOP). Being a `list`, the
object `rcolors` owns the *method* `function` that is called using the notation
**.**. No further knowledge of OOP than understanding the notation **.** is
necessary for going through this tutorial.
:::

:::{admonition} Discovering methods:
Reminder: in Ipython: tab-completion (press tab)

```python


rcolors.<TAB>
                 append()  count()   insert()  reverse()
                 clear()   extend()  pop()     sort()
                 copy()    index()   remove()
```
:::

### Strings

Different string syntaxes (simple, double or triple quotes):

```{python}
s = 'Hello, how are you?'
s = "Hi, what's up"
s = '''Hello,
       how are you'''         # tripling the quotes allows the
                              # string to span more than one line
s = """Hi,
what's up?"""
```

However, if you try to run this code:

```text
'Hi, what's up?'
```

â€” you will get a syntax error.  (Try it.)  (Why?)

This syntax error can be avoided by enclosing the string in double quotes
instead of single quotes. Alternatively, one can prepend a backslash to the
second single quote. Other uses of the backslash are, e.g., the newline
character `\n` and the tab character `\t`.

::: {note}
:class: dropdown

Strings are collections like lists. Hence they can be indexed and
sliced, using the same syntax and rules.
:::

Indexing:

```{python}
a = "hello"
a[0]
```

```{python}
a[1]
```

```{python}
a[-1]
```

::: {note}
:class: dropdown

(Remember that negative indices correspond to counting from the right
end.)
:::

Slicing:

```{python}
a = "hello, world!"
a[3:6] # 3rd to 6th (excluded) elements: elements 3, 4, 5
```

```{python}
a[2:10:2] # Syntax: a[start:stop:step]
```

```{python}
a[::3] # every three characters, from beginning to end
```

::: {note}
:class: dropdown

Accents and special characters can also be handled as in Python 3
strings consist of Unicode characters.
:::

A string is an **immutable object** and it is not possible to modify its
contents. One may however create new strings from the original one.

```{python tags=c("raises-exception")}
a = "hello, world!"
a[2] = 'z'
```

```{python}
a.replace('l', 'z', 1)
```

```{python}
a.replace('l', 'z')
```

::: {note}
:class: dropdown

Strings have many useful methods, such as `a.replace` as seen
above. Remember the `a.` object-oriented notation and use tab
completion or `help(str)` to search for new methods.
:::

:::{admonition} See also

Python offers advanced possibilities for manipulating strings,
looking for patterns or formatting. The interested reader is referred to
<https://docs.python.org/3/library/stdtypes.html#string-methods> and
<https://docs.python.org/3/library/string.html#format-string-syntax>
:::

String formatting:

```{python}
'An integer: %i; a float: %f; another string: %s' % (1, 0.1, 'string') # with more values use tuple after %
```

```{python}
i = 102
filename = 'processing_of_dataset_%d.txt' % i   # no need for tuples with just one value after %
filename
```

### Dictionaries

::: {note}
:class: dropdown

A dictionary is basically an efficient table that **maps keys to
values**.
:::

```{python}
tel = {'emmanuelle': 5752, 'sebastian': 5578}
tel['francis'] = 5915
tel
```

```{python}
tel['sebastian']
```

```{python}
tel.keys()
```

```{python}
tel.values()
```

```{python}
'francis' in tel
```

::: {note}
:class: dropdown

It can be used to conveniently store and retrieve values
associated with a name (a string for a date, a name, etc.). See
<https://docs.python.org/3/tutorial/datastructures.html#dictionaries>
for more information.

A dictionary can have keys (resp. values) with different types:

```{python}
d = {'a':1, 'b':2, 3:'hello'}
d
```
:::

### More container types

**Tuples**

Tuples are basically immutable lists. The elements of a tuple are written
between parentheses, or just separated by commas:

```{python}
t = 12345, 54321, 'hello!'
t[0]
```

```{python}
t
u = (0, 2)
```

**Sets:** unordered, unique items:

```{python}
s = set(('a', 'b', 'c', 'a'))
s
```

```{python}
s.difference(('a', 'b'))
```

## Assignment operator

::: {note}
:class: dropdown

[Python library reference](https://docs.python.org/3/reference/simple_stmts.html#assignment-statements)
says:

> Assignment statements are used to (re)bind names to values and to
> modify attributes or items of mutable objects.

In short, it works as follows (simple assignment):

1. an expression on the right hand side is evaluated, the corresponding
   object is created/obtained
2. a **name** on the left hand side is assigned, or bound, to the
   r.h.s. object
:::

Things to note:

- A single object can have several names bound to it:

```{python}
a = [1, 2, 3]
b = a
a
```

```{python}
b
```

```{python}
a is b
```

```{python}
b[1] = 'hi!'
a
```

- to change a list *in place*, use indexing/slices:

```{python}
a = [1, 2, 3]
a
```

```{python}
a = ['a', 'b', 'c'] # Creates another object.
a
```

```{python}
id(a)
```

```{python}
a[:] = [1, 2, 3] # Modifies object in place.
a
```

```{python}
id(a)
```

- the key concept here is **mutable vs. immutable**

  > - mutable objects can be changed in place
  > - immutable objects cannot be modified once created

:::{admonition} See also

A very good and detailed explanation of the above issues can
be found in David M. Beazley's article [Types and Objects in Python](https://www.informit.com/articles/article.aspx?p=453682).
:::
